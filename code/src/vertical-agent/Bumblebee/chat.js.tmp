// DOM Elements
const chatMessages = document.getElementById('chat-messages');
const chatForm = document.getElementById('chat-form');
const chatInput = document.getElementById('chat-input');
const newChatBtn = document.getElementById('new-chat-btn');
const uploadBtn = document.getElementById('upload-document-btn');
const uploadModal = document.getElementById('upload-modal');
const statusUpdateModal = document.getElementById('status-update-modal');
const uploadForm = document.getElementById('document-upload-form');
const uploadStatus = document.getElementById('upload-status');
const closeModalBtns = document.querySelectorAll('.modal-close, .modal-close-btn');
const renameChatBtn = document.getElementById('rename-chat-btn');
const deleteChatBtn = document.getElementById('delete-chat-btn');
const chatTitle = document.getElementById('current-chat-title');
const conversationsList = document.querySelector('.conversations-list');

// State
let currentConversationId = null;
let conversationsData = [];
let isProcessing = false;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // Initialize feather icons
    feather.replace();
    
    // Get the conversation ID from the active conversation
    const activeConversation = document.querySelector('.conversation-item.active');
    if (activeConversation) {
        currentConversationId = activeConversation.dataset.id;
        loadMessages(currentConversationId);
    } else {
        createNewConversation();
    }
    
    // Load all conversations for the sidebar
    loadConversations();
    
    // Load documents for the sidebar
    loadDocuments();
    
    // Load incidents for the sidebar
    loadIncidents();
    
    // Load recommendations column data
    loadAutomations();
    loadDashboards();
    loadLogs();
    
    // Setup auto-resize for textarea
    setupTextareaAutoResize();
    
    // Setup status update form submission
    const statusUpdateForm = document.getElementById('status-update-form');
    if (statusUpdateForm) {
        statusUpdateForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Get incident ID and new status from the modal's dataset
            const statusModal = document.getElementById('status-update-modal');
            const incidentId = statusModal.dataset.incidentId;
            const newStatus = statusModal.dataset.newStatus;
            
            // Get comments from the form
            const comments = document.getElementById('status-comments').value;
            
            // Update incident status with comments
            updateIncidentStatus(incidentId, newStatus, comments);
            
            // Hide the modal
            statusModal.style.display = 'none';
            
            // Clear form
            document.getElementById('status-comments').value = '';
        });
    }
});

// Event Listeners
chatForm.addEventListener('submit', handleChatSubmit);
newChatBtn.addEventListener('submit', createNewConversation);
newChatBtn.addEventListener('click', createNewConversation);
uploadBtn.addEventListener('click', () => uploadModal.style.display = 'block');
uploadForm.addEventListener('submit', handleDocumentUpload);
closeModalBtns.forEach(btn => {
    btn.addEventListener('click', function() {
        // Close all modals
        if (uploadModal) uploadModal.style.display = 'none';
        if (statusUpdateModal) statusUpdateModal.style.display = 'none';
    });
});
renameChatBtn.addEventListener('click', renameConversation);
deleteChatBtn.addEventListener('click', deleteConversation);

// Handle conversation click in sidebar
document.addEventListener('click', (e) => {
    const conversationItem = e.target.closest('.conversation-item');
    if (conversationItem) {
        const conversationId = conversationItem.dataset.id;
        changeConversation(conversationId);
    }
});

// Core Functions
function loadConversations() {
    fetch('/api/conversations/')
        .then(response => response.json())
        .then(data => {
            conversationsData = data;
            renderConversationsList(data);
        })
        .catch(error => console.error('Error loading conversations:', error));
}

function renderConversationsList(conversations) {
    conversationsList.innerHTML = '';
    
    conversations.forEach(conversation => {
        const isActive = conversation.id === currentConversationId;
        const conversationEl = document.createElement('div');
        conversationEl.className = `conversation-item ${isActive ? 'active' : ''}`;
        conversationEl.dataset.id = conversation.id;
        conversationEl.innerHTML = `
            <i data-feather="message-square"></i>
            <span class="conversation-title">${conversation.title}</span>
        `;
        conversationsList.appendChild(conversationEl);
    });
    
    // Re-initialize feather icons
    feather.replace();
}

function loadMessages(conversationId) {
    chatMessages.innerHTML = '';
    
    // Show loading indicator
    chatMessages.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
    
    fetch(`/api/conversations/${conversationId}/messages/`)
        .then(response => response.json())
        .then(data => {
            chatMessages.innerHTML = '';
            
            // Render each message
            data.forEach(message => {
                addMessageToUI(message.role, message.content);
            });
            
            // Scroll to bottom
            scrollToBottom();
        })
        .catch(error => {
            console.error('Error loading messages:', error);
            chatMessages.innerHTML = '<div class="message system"><div class="message-content">Failed to load messages. Please try again.</div></div>';
        });
}

function createNewConversation() {
    if (isProcessing) return;
    
    isProcessing = true;
    console.log("Creating new conversation...");
    
    fetch('/api/conversations/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken(),
        },
        body: JSON.stringify({
            title: 'New Conversation'
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("New conversation created:", data);
        
        // Update the current conversation state
        currentConversationId = data.id;
        chatTitle.textContent = data.title;
        
        // Clear chat messages
        chatMessages.innerHTML = '';
        
        // Update the UI
        loadConversations();
        loadMessages(currentConversationId);
        
        isProcessing = false;
    })
    .catch(error => {
        console.error('Error creating conversation:', error);
        alert('Failed to create a new conversation. Please try again.');
        isProcessing = false;
    });
}

function changeConversation(conversationId) {
    if (conversationId === currentConversationId || isProcessing) return;
    
    currentConversationId = conversationId;
    
    // Update active state in sidebar
    document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.toggle('active', item.dataset.id === conversationId);
    });
    
    // Find the conversation title
    const conversation = conversationsData.find(c => c.id === conversationId);
    if (conversation) {
        chatTitle.textContent = conversation.title;
    }
    
    // Load messages for this conversation
    loadMessages(conversationId);
}

function handleChatSubmit(e) {
    e.preventDefault();
    
    if (isProcessing) return;
    
    const userMessage = chatInput.value.trim();
    if (!userMessage) return;
    
    // Clear input
    chatInput.value = '';
    resetTextareaHeight();
    
    // Add user message to UI
    addMessageToUI('user', userMessage);
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.innerHTML = '<span></span><span></span><span></span>';
    chatMessages.appendChild(typingIndicator);
    scrollToBottom();
    
    isProcessing = true;
    
    // Send message to server
    fetch(`/api/conversations/${currentConversationId}/messages/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken(),
        },
        body: JSON.stringify({
            content: userMessage
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.text().then(text => {
                console.error('Message error details:', text);
                throw new Error(`HTTP error ${response.status}: ${text}`);
            });
        }
        return response.json();
    })
    .then(data => {
        // Remove typing indicator
        if (typingIndicator.parentNode) {
            typingIndicator.parentNode.removeChild(typingIndicator);
        }
        
        console.log('Response data:', data);
        
        // The response contains both the user message and the assistant's response(s)
        // We've already added the user message, so we just need the assistant's response(s)
        if (Array.isArray(data)) {
            // Find all assistant messages in the response
            const assistantMessages = data.filter(msg => msg.role === 'assistant');
            
            // Add all assistant messages to UI
            for (const msg of assistantMessages) {
                addMessageToUI('assistant', msg.content);
            }
        } else if (data.role === 'assistant') {
            // Handle case where only one message is returned
            addMessageToUI('assistant', data.content);
        }
        
        isProcessing = false;
        scrollToBottom();
    })
    .catch(error => {
        console.error('Error sending message:', error);
        
        // Remove typing indicator
        if (typingIndicator.parentNode) {
            typingIndicator.parentNode.removeChild(typingIndicator);
        }
        
        // Add error message
        addMessageToUI('system', 'Failed to send message. Please try again.');
        
        isProcessing = false;
        scrollToBottom();
    });
}

function handleDocumentUpload(e) {
    e.preventDefault();
    
    if (isProcessing) return;
    
    const fileInput = document.getElementById('document-file');
    const file = fileInput.files[0];
    
    if (!file) {
        updateUploadStatus('Please select a file to upload.', 'error');
        return;
    }
    
    // Check file type
    const fileExtension = file.name.split('.').pop().toLowerCase();
    const allowedTypes = ['pdf', 'docx', 'doc', 'txt', 'md'];
    
    if (!allowedTypes.includes(fileExtension)) {
        updateUploadStatus(`File type .${fileExtension} is not supported. Please use PDF, DOCX, TXT, or MD files.`, 'error');
        return;
    }
    
    // Update UI
    updateUploadStatus('Uploading document...', 'info');
    isProcessing = true;
    
    // Create form data
    const formData = new FormData();
    formData.append('file', file);
    
    // Send to server - don't include Content-Type header with FormData
    fetch('/api/documents/upload/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            // Let browser set Content-Type with boundary for FormData
        },
        body: formData,
        credentials: 'same-origin' // Include cookies for CSRF
    })
    .then(response => {
        if (!response.ok) {
            return response.text().then(text => {
                console.error('Upload error details:', text);
                throw new Error(`HTTP error ${response.status}: ${text}`);
            });
        }
        return response.json();
    })
    .then(data => {
        updateUploadStatus(`Document "${data.title}" uploaded successfully!`, 'success');
        
        // Reset form
        fileInput.value = '';
        
        // Reload document list
        loadDocuments();
        
        // Close modal after a delay
        setTimeout(() => {
            uploadModal.style.display = 'none';
            updateUploadStatus('', '');
        }, 2000);
        
        isProcessing = false;
    })
    .catch(error => {
        console.error('Error uploading document:', error);
        updateUploadStatus('Failed to upload document. Please try again.', 'error');
        isProcessing = false;
    });
}

function renameConversation() {
    if (isProcessing || !currentConversationId) return;
    
    const newTitle = prompt('Enter a new name for this conversation:', chatTitle.textContent);
    
    if (newTitle === null || newTitle.trim() === '') return;
    
    isProcessing = true;
    
    fetch(`/api/conversations/${currentConversationId}/`, {
        method: 'PATCH',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken(),
        },
        body: JSON.stringify({
            title: newTitle.trim()
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // Update title in UI
        chatTitle.textContent = data.title;
        
        // Update in sidebar
        loadConversations();
        
        isProcessing = false;
    })
    .catch(error => {
        console.error('Error renaming conversation:', error);
        alert('Failed to rename conversation. Please try again.');
        isProcessing = false;
    });
}

function deleteConversation() {
    if (!currentConversationId) {
        console.log('No conversation selected');
        return;
    }
    
    if (isProcessing) {
        console.log('Already processing a request');
        return;
    }
    
    if (!confirm('Are you sure you want to delete this conversation? This action cannot be undone.')) {
        return;
    }
    
    isProcessing = true;
    const deletedId = currentConversationId;
    
    fetch(`/api/conversations/${currentConversationId}/`, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': getCSRFToken(),
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
        }
        
        console.log("Successfully deleted conversation:", deletedId);
        
        // Reset current conversation ID
        currentConversationId = null;
        
        // Clear messages and title
        chatMessages.innerHTML = '';
        chatTitle.textContent = '';
        
        // Remove the deleted conversation from the list and data
        const deletedElement = document.querySelector(`.conversation-item[data-id="${deletedId}"]`);
        if (deletedElement) {
            deletedElement.remove();
        }
        conversationsData = conversationsData.filter(conv => conv.id !== deletedId);
        
        // Create a new conversation immediately
        return createNewConversation();
    })
    .then(() => {
        // Force refresh the conversations list
        return fetch('/api/conversations/')
            .then(response => response.json())
            .then(data => {
                conversationsData = data;
                renderConversationsList(data);
            });
    })
    .catch(error => {
        console.error('Error in conversation deletion flow:', error);
    })
    .finally(() => {
        isProcessing = false;
    });
}

// Make createNewConversation return a promise
function createNewConversation() {
    if (isProcessing) return Promise.reject('Processing in progress');
    
    isProcessing = true;
    console.log("Creating new conversation...");
    
    return fetch('/api/conversations/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken(),
        },
        body: JSON.stringify({
            title: 'New Conversation'
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("New conversation created:", data);
        
        // Update the current conversation state
        currentConversationId = data.id;
        chatTitle.textContent = data.title;
        
        // Clear chat messages
        chatMessages.innerHTML = '';
        
        // Refresh conversations list immediately
        return fetch('/api/conversations/')
            .then(response => response.json())
            .then(conversations => {
                conversationsData = conversations;
                renderConversationsList(conversations);
                return loadMessages(currentConversationId);
            });
    })
    .finally(() => {
        isProcessing = false;
    });
}

// Helper Functions
function addMessageToUI(role, content) {
    const messageEl = document.createElement('div');
    messageEl.className = `message ${role}`;
    
    // Format message content - handle markdown-like syntax
    let formattedContent = content
        // Bold text
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        // Code blocks
        .replace(/```([^`]+)```/g, '<pre><code>$1</code></pre>')
        // Inline code
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // Newlines
        .replace(/\n/g, '<br>');
    
    messageEl.innerHTML = `<div class="message-content">${formattedContent}</div>`;
    chatMessages.appendChild(messageEl);
    scrollToBottom();
}

function scrollToBottom() {
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function updateUploadStatus(message, type) {
    uploadStatus.textContent = message;
    uploadStatus.className = 'upload-status';
    if (type) {
        uploadStatus.classList.add(type);
    }
}

function setupTextareaAutoResize() {
    chatInput.addEventListener('input', () => {
        chatInput.style.height = 'auto';
        chatInput.style.height = (chatInput.scrollHeight) + 'px';
    });
}

function resetTextareaHeight() {
    chatInput.style.height = 'auto';
}

function getCSRFToken() {
    // Get CSRF token from cookie
    const cookieValue = document.cookie
        .split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
    
    return cookieValue || '';
}

// Document list functions
function loadDocuments() {
    fetch('/api/documents/')
        .then(response => response.json())
        .then(documents => {
            renderDocumentsList(documents);
        })
        .catch(error => {
            console.error('Error loading documents:', error);
            document.getElementById('documents-list').innerHTML = 
                '<div class="loading-documents">Failed to load documents. Please try again.</div>';
        });
}

function renderDocumentsList(documents) {
    const documentsListEl = document.getElementById('documents-list');
    
    // Empty the list first
    documentsListEl.innerHTML = '';
    
    if (documents.length === 0) {
        documentsListEl.innerHTML = '<div class="loading-documents">No documents uploaded yet.</div>';
        return;
    }
    
    // Add each document to the list
    documents.forEach(doc => {
        const docEl = document.createElement('div');
        docEl.className = 'document-item';
        docEl.setAttribute('data-id', doc.id);
        
        // Get icon based on file type
        let iconName = 'file-text';
        if (doc.file_type === 'pdf') {
            iconName = 'file-text';
        } else if (doc.file_type === 'word') {
            iconName = 'file';
        }
        
        docEl.innerHTML = `
            <div class="document-icon">
                <i data-feather="${iconName}"></i>
            </div>
            <div class="document-title">${doc.title}</div>
            <div class="document-delete" title="Delete document">
                <i data-feather="trash-2"></i>
            </div>
        `;
        
        documentsListEl.appendChild(docEl);
        
        // Add event listener for delete button
        const deleteBtn = docEl.querySelector('.document-delete');
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('Are you sure you want to delete this document? This action cannot be undone.')) {
                deleteDocument(doc.id);
            }
        });
    });
    
    // Reinitialize Feather icons
    feather.replace();
}

function deleteDocument(documentId) {
    fetch(`/api/documents/${documentId}/delete/`, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': getCSRFToken(),
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
        }
        
        // Remove the document element from UI
        const docElement = document.querySelector(`.document-item[data-id="${documentId}"]`);
        if (docElement) {
            docElement.remove();
        }
        
        // Reload documents to ensure sync
        loadDocuments();
    })
    .catch(error => {
        console.error('Error deleting document:', error);
        alert('Failed to delete document. Please try again.');
    });
}

// Handle modal window outside click to close
window.addEventListener('click', (e) => {
    if (e.target === uploadModal) {
        uploadModal.style.display = 'none';
    }
});

// Incidents List Functions
function loadIncidents() {
    const incidentsList = document.getElementById('incidents-list');
    if (!incidentsList) return;

    fetch('/api/incidents')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(incidents => {
            renderIncidentsList(incidents);
        })
        .catch(error => {
            console.error('Error loading incidents:', error);
            incidentsList.innerHTML = '<div class="loading-incidents">Failed to load incidents. Please try again.</div>';
        });
}

function renderIncidentsList(incidents) {
    const incidentsListEl = document.getElementById('incidents-list');
    if (!incidentsListEl) return;
    
    // Empty the list first
    incidentsListEl.innerHTML = '';
    
    if (!incidents || incidents.length === 0) {
        incidentsListEl.innerHTML = '<div class="loading-incidents">No incidents reported yet.</div>';
        return;
    }
    
    // Add each incident to the list
    incidents.forEach(incident => {
        const incidentEl = document.createElement('div');
        incidentEl.className = 'incident-item';
        incidentEl.setAttribute('data-id', incident.id);
        
        // Determine severity class and icon
        let severityClass = 'medium';
        let severityIcon = incident.status === 'resolved' ? 'check-circle' : 'alert-triangle';
        
        if (incident.severity === 'high' && incident.status !== 'resolved') {
            severityClass = 'high';
            severityIcon = 'alert-circle';
        } else if (incident.severity === 'low' && incident.status !== 'resolved') {
            severityClass = 'low';
            severityIcon = 'alert-octagon';
        }
        
        // Format status for display
        const statusClass = incident.status.toLowerCase().replace(' ', '-');
        const statusDisplay = incident.status.charAt(0).toUpperCase() + incident.status.slice(1);
        
        incidentEl.innerHTML = `
            <div class="incident-icon ${severityClass}">
                <i data-feather="${severityIcon}"></i>
            </div>
            <div class="incident-title">${incident.title}</div>
            <div class="incident-status ${statusClass}">${statusDisplay}</div>
        `;
        
        // Add click event to show incident details
        incidentEl.addEventListener('click', () => {
            showIncidentDetails(incident);
            highlightIncident(incidentEl);
        });
        
        incidentsListEl.appendChild(incidentEl);
    });
    
    // Reinitialize Feather icons
    feather.replace();
}

// Load incidents initially and refresh periodically
loadIncidents();
setInterval(loadIncidents, 30000); // Refresh every 30 seconds

// Handle escape key to close modal
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && uploadModal.style.display === 'block') {
        uploadModal.style.display = 'none';
    }
});
function showIncidentDetails(incident) {
    const detailsContainer = document.getElementById('incident-details');
    const currentIncidentId = incident.id;
    
    // Generate the details HTML with summary information included
    detailsContainer.innerHTML = `
        <h3>${incident.title}</h3>
        <div class="incident-details-meta">
            <span class="${incident.severity.toLowerCase()}">Severity: ${incident.severity}</span>
            <span class="${incident.status.toLowerCase().replace(' ', '-')}">Status: ${incident.status}</span>
        </div>
        <p>${incident.description}</p>
        <div class="incident-summary-section">
            <h4>Incident Summary</h4>
            <p>This ${incident.severity} severity incident is currently ${incident.status}.</p>
            <p>${getIncidentImpactSummary(incident)}</p>
        </div>
        <div class="incident-timestamp">Reported: ${new Date(incident.created_at).toLocaleString()}</div>
        
        <!-- Status Update Controls -->
        <div id="incident-status-controls" class="incident-status-update" style="display: flex;">
            <label for="status-select">Status:</label>
            <select id="status-select" class="status-select">
                <option value="open">Open</option>
                <option value="in-progress">In Progress</option>
                <option value="resolved">Resolved</option>
            </select>
            <button id="update-status-btn" class="update-status-btn">Update</button>
        </div>
    `;
    
    // Get the newly created status controls
    const statusControlsDiv = document.getElementById('incident-status-controls');
    const statusSelect = document.getElementById('status-select');
    
    // Set current status as selected
    if (statusSelect) {
        console.log("Found status select:", statusSelect);
        // Convert status to lowercase and replace spaces with hyphens to match option values
        const currentStatus = incident.status.toLowerCase().replace(' ', '-');
        
        // Find and select the matching option
        for (let i = 0; i < statusSelect.options.length; i++) {
            if (statusSelect.options[i].value === currentStatus) {
                statusSelect.selectedIndex = i;
                break;
            }
        }
    }
    
    // Set up event listener for the update button
    const updateButton = document.getElementById('update-status-btn');
    if (updateButton) {
        // Remove previous event listeners by cloning and replacing
        const newUpdateBtn = updateButton.cloneNode(true);
        updateButton.parentNode.replaceChild(newUpdateBtn, updateButton);
        
        // Add new event listener
        newUpdateBtn.addEventListener('click', () => {
            const newStatus = document.getElementById('status-select').value;
            
            // Store the current incident ID and status in the form for later use
            const statusModal = document.getElementById('status-update-modal');
            statusModal.dataset.incidentId = currentIncidentId;
            statusModal.dataset.newStatus = newStatus;
            
            // Show the comments modal
            statusModal.style.display = 'block';
        });
    }
    
    // Fetch incident details with recommendations
    fetch(`/api/incidents/${incident.id}/`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            // Update recommendations based on incident
            updateRecommendedAutomations(data.recommended_automations || []);
            updateRecommendedDashboards(data.recommended_dashboards || []);
        })
        .catch(error => {
            console.error('Error fetching incident recommendations:', error);
        });
    
    // We keep the incidents overview visible
}

// Helper function to generate impact summary based on incident severity and status
function getIncidentImpactSummary(incident) {
    if (incident.severity === 'high' && incident.status === 'open') {
        return 'This incident requires immediate attention as it may be causing significant service disruption.';
    } else if (incident.severity === 'high' && incident.status === 'resolved') {
        return 'This critical incident has been resolved. A post-mortem analysis is recommended.';
    } else if (incident.severity === 'medium') {
        return 'This incident has moderate impact on services and should be addressed promptly.';
    } else if (incident.severity === 'low') {
        return 'This is a low-impact incident that should be monitored but is not causing significant issues.';
    } else {
        return 'Monitor this incident for any changes or escalations that may require attention.';
    }
}

function highlightIncident(element) {
    // Remove highlight from other incidents
    document.querySelectorAll('.incident-item').forEach(item => {
        item.style.backgroundColor = 'white';
    });
    // Highlight clicked incident
    element.style.backgroundColor = '#f0f0f0';
}

// Function to update incident status
function updateIncidentStatus(incidentId, newStatus, comments = '') {
    // Format the status value for the API (convert to title case)
    let apiStatus = newStatus.replace(/-/g, ' ').replace(/\w\S*/g, 
        function(txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        }
    );
    
    // Prepare request data
    const requestData = {
        status: apiStatus
    };
    
    // Add comments if provided
    if (comments) {
        requestData.comments = comments;
    }
    
    // Send PUT request to update incident
    fetch(`/api/incidents/${incidentId}/`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify(requestData)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to update incident status');
        }
        return response.json();
    })
    .then(updatedIncident => {
        // Update the UI with the new incident data
        showIncidentDetails(updatedIncident);
        
        // Also update the incident in the list
        updateIncidentInList(updatedIncident);
        
        // Show success message
        const detailsContainer = document.getElementById('incident-details');
        const successMsg = document.createElement('div');
        successMsg.className = 'status-update-success';
        successMsg.textContent = `Status updated to ${apiStatus}`;
        successMsg.style.color = 'green';
        successMsg.style.marginTop = '10px';
        detailsContainer.appendChild(successMsg);
        
        // Remove success message after 3 seconds
        setTimeout(() => {
            if (successMsg.parentNode) {
                successMsg.parentNode.removeChild(successMsg);
            }
        }, 3000);
        
        // Reload the incidents list to reflect the updates
        loadIncidents();
    })
    .catch(error => {
        console.error('Error updating incident status:', error);
        // Show error message
        const detailsContainer = document.getElementById('incident-details');
        const errorMsg = document.createElement('div');
        errorMsg.className = 'status-update-error';
        errorMsg.textContent = 'Failed to update status. Please try again.';
        errorMsg.style.color = 'red';
        errorMsg.style.marginTop = '10px';
        detailsContainer.appendChild(errorMsg);
        
        // Remove error message after 3 seconds
        setTimeout(() => {
            if (errorMsg.parentNode) {
                errorMsg.parentNode.removeChild(errorMsg);
            }
        }, 3000);
    });
}

// Function to update a single incident in the list
function updateIncidentInList(updatedIncident) {
    const incidentElement = document.querySelector(`.incident-item[data-id="${updatedIncident.id}"]`);
    if (incidentElement) {
        const statusElement = incidentElement.querySelector('.incident-status');
        if (statusElement) {
            // Update the status class and text
            const oldStatusClass = statusElement.className.split(' ')[1];
            const newStatusClass = updatedIncident.status.toLowerCase().replace(' ', '-');
            statusElement.classList.remove(oldStatusClass);
            statusElement.classList.add(newStatusClass);
            statusElement.textContent = updatedIncident.status;
        }
    }
}

function updateIncidentsSummary(incidents) {
    const summaryContainer = document.getElementById('incident-summary');
    if (!summaryContainer) return;
    
    // Count incidents by status and severity
    let openIncidents = incidents.filter(inc => inc.status === 'open').length;
    let inProgressIncidents = incidents.filter(inc => inc.status === 'in-progress').length;
    let resolvedIncidents = incidents.filter(inc => inc.status === 'resolved').length;
    let highSeverityIncidents = incidents.filter(inc => inc.severity === 'high').length;
    
    // Create the HTML for the incident summary section
    let summaryHTML = `
        <h3>Incidents Overview</h3>
        <div class="summary-content">
            <div class="summary-stats">
                <div class="severity-item high">
                    <span>High Severity</span>
                    <span>${highSeverityIncidents}</span>
                </div>
                <div class="severity-item">
                    <span>Open</span>
                    <span>${openIncidents}</span>
                </div>
                <div class="severity-item">
                    <span>In Progress</span>
                    <span>${inProgressIncidents}</span>
                </div>
                <div class="severity-item">
                    <span>Resolved</span>
                    <span>${resolvedIncidents}</span>
                </div>
            </div>
            
            <div class="summary-note">
                <p>Select an incident for details</p>
            </div>
        </div>
    `;
    
    // Update the summary container with our HTML
    summaryContainer.innerHTML = summaryHTML;
}

// Update loadIncidents function to include summary
function loadIncidents() {
    const incidentsList = document.getElementById('incidents-list');
    if (!incidentsList) return;

    fetch('/api/incidents')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(incidents => {
            renderIncidentsList(incidents);
            updateIncidentsSummary(incidents);
        })
        .catch(error => {
            console.error('Error loading incidents:', error);
            incidentsList.innerHTML = '<div class="loading-incidents">Failed to load incidents. Please try again.</div>';
        });
}

// Function to load automations for the recommendations column
function loadAutomations() {
    const automationsList = document.getElementById('automations-list');
    if (!automationsList) return;

    fetch('/api/automations/')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(automations => {
            renderAutomationsList(automations);
        })
        .catch(error => {
            console.error('Error loading automations:', error);
            automationsList.innerHTML = '<div class="loading-automations">Failed to load automations. Please try again.</div>';
        });
}

// Function to update recommended automations based on incident selection
function updateRecommendedAutomations(automations) {
    const automationsList = document.getElementById('automations-list');
    if (!automationsList) return;
    
    // If no recommended automations, show message
    if (!automations || automations.length === 0) {
        automationsList.innerHTML = '<div class="empty-state">No relevant automations found for this incident</div>';
        return;
    }
    
    let html = '<h4>Recommended Automations</h4>';
    automations.forEach(automation => {
        html += `
            <div class="automation-item recommended" data-id="${automation.id}">
                <div class="automation-name">${automation.name}</div>
                <div class="automation-description">${automation.description}</div>
                <button class="run-btn" data-id="${automation.id}">Run</button>
            </div>
        `;
    });
    
    automationsList.innerHTML = html;
    
    // Add event listeners to run buttons
    document.querySelectorAll('.automation-item .run-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const automationId = this.dataset.id;
            triggerAutomation(automationId);
        });
    });
}

// Function to render the automations list
function renderAutomationsList(automations) {
    const automationsList = document.getElementById('automations-list');
    if (!automationsList) return;
    
    if (automations.length === 0) {
        automationsList.innerHTML = '<div class="empty-state">No automations available</div>';
        return;
    }
    
    let html = '';
    automations.forEach(automation => {
        html += `
            <div class="automation-item" data-id="${automation.id}">
                <div class="automation-name">${automation.name}</div>
                <div class="automation-description">${automation.description}</div>
                <button class="run-btn" data-id="${automation.id}">Run</button>
            </div>
        `;
    });
    
    automationsList.innerHTML = html;
    
    // Add event listeners to run buttons
    document.querySelectorAll('.automation-item .run-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const automationId = this.dataset.id;
            triggerAutomation(automationId);
        });
    });
}

// Function to trigger an automation
function triggerAutomation(automationId) {
    fetch(`/api/automations/${automationId}/trigger/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify({})
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to trigger automation');
        }
        return response.json();
    })
    .then(data => {
        alert(`Automation triggered successfully: ${data.message || 'Completed'}`);
    })
    .catch(error => {
        console.error('Error triggering automation:', error);
        alert('Failed to trigger automation. Please try again.');
    });
}

// Function to load dashboards for the recommendations column
function loadDashboards() {
    const dashboardsList = document.getElementById('dashboards-list');
    if (!dashboardsList) return;

    fetch('/api/dashboards/')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(dashboards => {
            renderDashboardsList(dashboards);
        })
        .catch(error => {
            console.error('Error loading dashboards:', error);
            dashboardsList.innerHTML = '<div class="loading-dashboards">Failed to load dashboards. Please try again.</div>';
        });
}

// Function to update recommended dashboards based on incident selection
function updateRecommendedDashboards(dashboards) {
    const dashboardsList = document.getElementById('dashboards-list');
    if (!dashboardsList) return;
    
    // If no recommended dashboards, show message
    if (!dashboards || dashboards.length === 0) {
        dashboardsList.innerHTML = '<div class="empty-state">No relevant dashboards found for this incident</div>';
        return;
    }
    
    let html = '<h4>Recommended Dashboards</h4>';
    dashboards.forEach(dashboard => {
        html += `
            <div class="dashboard-item recommended">
                <div class="dashboard-name">${dashboard.name}</div>
                <div class="dashboard-description">${dashboard.description}</div>
                <a href="${dashboard.link}" target="_blank" class="dashboard-link">Open Dashboard <i data-feather="external-link"></i></a>
            </div>
        `;
    });
    
    dashboardsList.innerHTML = html;
    
    // Initialize feather icons
    feather.replace();
}

// Function to render the dashboards list
function renderDashboardsList(dashboards) {
    const dashboardsList = document.getElementById('dashboards-list');
    if (!dashboardsList) return;
    
    if (dashboards.length === 0) {
        dashboardsList.innerHTML = '<div class="empty-state">No dashboards available</div>';
        return;
    }
    
    let html = '';
    dashboards.forEach(dashboard => {
        html += `
            <div class="dashboard-item">
                <div class="dashboard-name">${dashboard.name}</div>
                <div class="dashboard-description">${dashboard.description}</div>
                <a href="${dashboard.link}" target="_blank" class="dashboard-link">Open Dashboard <i data-feather="external-link"></i></a>
            </div>
        `;
    });
    
    dashboardsList.innerHTML = html;
    
    // Initialize feather icons
    feather.replace();
}

// Function to load logs for the recommendations column
function loadLogs() {
    const logsList = document.getElementById('logs-list');
    if (!logsList) return;

    fetch('/api/logs/')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(logs => {
            renderLogsList(logs);
        })
        .catch(error => {
            console.error('Error loading logs:', error);
            logsList.innerHTML = '<div class="loading-logs">Failed to load logs. Please try again.</div>';
        });
}

// Function to render the logs list
function renderLogsList(logs) {
    const logsList = document.getElementById('logs-list');
    if (!logsList) return;
    
    if (logs.length === 0) {
        logsList.innerHTML = '<div class="empty-state">No logs available</div>';
        return;
    }
    
    let html = '';
    logs.forEach(log => {
        const logClass = `log-${log.level.toLowerCase()}`;
        html += `
            <div class="log-item ${logClass}">
                <div class="log-timestamp">${new Date(log.timestamp).toLocaleString()}</div>
                <div class="log-source">${log.source}</div>
                <div class="log-message">${log.message}</div>
            </div>
        `;
    });
    
    logsList.innerHTML = html;
}
